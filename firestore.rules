rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user has access to a resource
    function hasAccess(resource) {
      return request.auth != null && (
        request.auth.uid == resource.data.owner ||
        (resource.data.sharedWith is list && request.auth.uid in resource.data.sharedWith)
      );
    }
    
    // Helper function to validate user owns the resource being created
    function isOwner(resourceData) {
      return request.auth != null && request.auth.uid == resourceData.owner;
    }
    
    // Helper function to ensure sharedWith array is properly formatted
    function validSharedWith(sharedWith) {
      return sharedWith is list && 
             sharedWith.size() <= 100 && // Reasonable limit
             request.auth.uid in sharedWith; // Creator must be in sharedWith list
    }
    
    // Users can read and write their own profile
    match /users/{userId} {
      // Full read/write access to own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow authenticated users to query users by email for sharing purposes
      // This allows reading public profile info (email, publicKey, displayName) needed for encryption and sharing
      // Private keys are stored encrypted so this is safe
      allow read: if request.auth != null;
    }
    
    // Folders - OWNER ONLY ACCESS (folders are not shared, only files within them)
    match /folders/{folderId} {
      // Read access: OWNER ONLY - folders themselves are private
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Write access: OWNER ONLY
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner - no sharing for folders themselves
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.owner &&
        // Ensure required fields are present
        request.resource.data.keys().hasAll(['owner', 'name', 'parent', 'createdAt']) &&
        // Validate data types
        request.resource.data.owner is string &&
        (request.resource.data.parent == null || request.resource.data.parent is string);
    }
    
    // Files (including forms) - users can access files they own or files shared with them
    match /files/{fileId} {
      // Read access: owner or explicitly shared user
      allow read: if hasAccess(resource);
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Allow users with access to update only their favorite status
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isFavorite', 'lastModified']) &&
        request.resource.data.isFavorite is bool;
      
      // Create access: must be owner and include self in sharedWith
      allow create: if isOwner(request.resource.data) && 
        validSharedWith(request.resource.data.sharedWith) &&
        // Ensure required fields are present for files/forms
        request.resource.data.keys().hasAll(['owner', 'name', 'size', 'storagePath', 'encryptedKeys', 'sharedWith', 'createdAt']) &&
        // Validate data types
        request.resource.data.owner is string &&
        request.resource.data.storagePath is string &&
        request.resource.data.encryptedKeys is map &&
        // Ensure user has an encrypted key for the file
        request.auth.uid in request.resource.data.encryptedKeys &&
        // Parent folder validation (if specified)
        (request.resource.data.parent == null || request.resource.data.parent is string);
    }
    
    // Groups - users can access groups they own or are members of
    match /groups/{groupId} {
      // Read access: owner or member
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.owner ||
        (resource.data.members is list && request.auth.uid in resource.data.members)
      );
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner and include self in members
      allow create: if isOwner(request.resource.data) &&
        request.resource.data.members is list &&
        request.auth.uid in request.resource.data.members &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['owner', 'name', 'members', 'createdAt', 'updatedAt']) &&
        // Reasonable member limit
        request.resource.data.members.size() <= 50;
    }
    
    // Sharing History - users can only access their own sharing history
    match /sharingHistory/{historyId} {
      // Read access: only owner
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner
      allow create: if isOwner(request.resource.data) &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['owner', 'sharedWith', 'sharedAt', 'type']) &&
        // Validate data types
        request.resource.data.owner is string &&
        request.resource.data.sharedWith is string &&
        request.resource.data.type in ['user', 'group'];
    }
    
    // Form Templates - public templates accessible by all, private templates by owner/shared users
    match /formTemplates/{templateId} {
      // Helper function to check if user can access template
      function canAccessTemplate(templateData) {
        return templateData.isPublic == true || 
               request.auth.uid == templateData.author ||
               (templateData.sharedWith is list && request.auth.uid in templateData.sharedWith);
      }
      
      // Read access: public templates, owned templates, or shared templates
      allow read: if request.auth != null && canAccessTemplate(resource.data);
      
      // Write access: only template author can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.author;
      
      // Create access: must be author
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.author &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['name', 'author', 'isPublic', 'isOfficial', 'schema', 'defaultData', 'usageCount', 'createdAt', 'updatedAt']) &&
        // Validate data types
        request.resource.data.name is string &&
        request.resource.data.author is string &&
        request.resource.data.isPublic is bool &&
        request.resource.data.isOfficial is bool &&
        request.resource.data.schema is map &&
        request.resource.data.defaultData is map &&
        request.resource.data.usageCount is number &&
        // Only allow isOfficial=true if user has admin claim (you'll need to set this in custom claims)
        (request.resource.data.isOfficial == false || request.auth.token.admin == true) &&
        // Validate sharedWith array if present
        (!request.resource.data.keys().hasAny(['sharedWith']) || 
         (request.resource.data.sharedWith is list && request.resource.data.sharedWith.size() <= 100));
    }
    
    // Custom Templates - users can manage their own templates, read public ones
    match /customTemplates/{templateId} {
      // Helper function to check if user can access template
      function canAccessCustomTemplate(templateData) {
        return templateData.isPublic == true || 
               request.auth.uid == templateData.userId;
      }
      
      // Read access: public templates or owned templates
      allow read: if request.auth != null && canAccessCustomTemplate(resource.data);
      
      // Write access: only template owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Create access: must be owner
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['templateId', 'name', 'userId', 'isCustom', 'schema', 'created', 'modified']) &&
        // Validate data types
        request.resource.data.templateId is string &&
        request.resource.data.name is string &&
        request.resource.data.userId is string &&
        request.resource.data.isCustom == true &&
        request.resource.data.schema is map &&
        // Validate that isPublic is boolean if present
        (!request.resource.data.keys().hasAny(['isPublic']) || request.resource.data.isPublic is bool) &&
        // Custom templates can never be official
        (!request.resource.data.keys().hasAny(['isOfficial']) || request.resource.data.isOfficial == false);
    }
    
    // Deny all other access - explicit security
    match /{document=**} {
      allow read, write: if false;
    }
  }
}