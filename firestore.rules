rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user has access to a resource
    function hasAccess(resource) {
      return request.auth != null && (
        request.auth.uid == resource.data.owner ||
        (resource.data.sharedWith is list && request.auth.uid in resource.data.sharedWith)
      );
    }
    
    // Helper function to validate user owns the resource being created
    function isOwner(resourceData) {
      return request.auth != null && request.auth.uid == resourceData.owner;
    }
    
    // Helper function to ensure sharedWith array is properly formatted
    function validSharedWith(sharedWith) {
      return sharedWith is list && 
             sharedWith.size() <= 100 && // Reasonable limit
             request.auth.uid in sharedWith; // Creator must be in sharedWith list
    }
    
    // Users can read and write their own profile
    match /users/{userId} {
      // Full read/write access to own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow authenticated users to query users by email for sharing purposes
      // This allows reading public profile info (email, publicKey, displayName) needed for encryption and sharing
      // Private keys are stored encrypted so this is safe
      allow read: if request.auth != null;
    }
    
    // Folders - OWNER ONLY ACCESS (folders are not shared, only files within them)
    match /folders/{folderId} {
      // Read access: OWNER ONLY - folders themselves are private
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Write access: OWNER ONLY
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner - no sharing for folders themselves
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.owner &&
        // Ensure required fields are present
        request.resource.data.keys().hasAll(['owner', 'name', 'parent', 'createdAt']) &&
        // Validate data types
        request.resource.data.owner is string &&
        (request.resource.data.parent == null || request.resource.data.parent is string);
    }
    
    // Files (including forms) - users can access files they own or files shared with them
    match /files/{fileId} {
      // Read access: owner or explicitly shared user
      allow read: if hasAccess(resource);
      
      // List access: allow querying files where user is owner or in sharedWith array
      allow list: if request.auth != null;
      
      // Write access: only owner can modify most fields
      allow update, delete: if request.auth != null &&
        request.auth.uid == resource.data.owner;

      // Allow users to remove themselves from sharedWith array (unshare operation)
      allow update: if request.auth != null &&
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['sharedWith']) &&
        request.resource.data.sharedWith is list &&
        // User must be removing themselves from the array
        request.auth.uid in resource.data.sharedWith &&
        !(request.auth.uid in request.resource.data.sharedWith) &&
        // Can't remove the owner from sharedWith
        resource.data.owner in request.resource.data.sharedWith;
      
      // Allow users with access to update only their favorite status (legacy field)
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isFavorite', 'lastModified']) &&
        request.resource.data.isFavorite is bool;
        
      // Allow users with access to update their own favorite status in userFavorites
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userFavorites', 'lastModified']) &&
        request.resource.data.userFavorites is map &&
        // Only allow modification of the user's own favorite status
        request.auth.uid in request.resource.data.userFavorites.keys() &&
        request.resource.data.userFavorites[request.auth.uid] is bool;
      
      // Allow users with access to update their own folder association in userFolders
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userFolders']) &&
        request.resource.data.userFolders is map &&
        // Only allow modification of the user's own folder association
        (request.resource.data.userFolders.size() == resource.data.get('userFolders', {}).size() ||
         request.resource.data.userFolders.size() == resource.data.get('userFolders', {}).size() + 1) &&
        // Ensure user can only modify their own entry
        request.auth.uid in request.resource.data.userFolders.keys();
      
      // Allow users with access to update their own encrypted tags in userTags
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userTags']) &&
        request.resource.data.userTags is map &&
        // Only allow modification of the user's own encrypted tags
        (request.resource.data.userTags.size() == resource.data.get('userTags', {}).size() ||
         request.resource.data.userTags.size() == resource.data.get('userTags', {}).size() + 1) &&
        // Ensure user can only modify their own entry and it's properly encrypted
        request.auth.uid in request.resource.data.userTags.keys() &&
        request.resource.data.userTags[request.auth.uid] is map &&
        request.resource.data.userTags[request.auth.uid].keys().hasAll(['ciphertext', 'nonce']) &&
        request.resource.data.userTags[request.auth.uid].ciphertext is string &&
        request.resource.data.userTags[request.auth.uid].nonce is string;
      
      // Allow users with access to update their own personalized name in userNames
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userNames', 'lastModified']) &&
        request.resource.data.userNames is map &&
        // Only allow modification of the user's own personalized name
        (request.resource.data.userNames.size() == resource.data.get('userNames', {}).size() ||
         request.resource.data.userNames.size() == resource.data.get('userNames', {}).size() + 1) &&
        // Ensure user can only modify their own entry and it's properly encrypted
        request.auth.uid in request.resource.data.userNames.keys() &&
        request.resource.data.userNames[request.auth.uid] is map &&
        request.resource.data.userNames[request.auth.uid].keys().hasAll(['ciphertext', 'nonce']) &&
        request.resource.data.userNames[request.auth.uid].ciphertext is string &&
        request.resource.data.userNames[request.auth.uid].nonce is string;
      
      // Create access: must be owner and include self in sharedWith
      allow create: if isOwner(request.resource.data) && 
        validSharedWith(request.resource.data.sharedWith) &&
        // Ensure required fields are present for files/forms
        request.resource.data.keys().hasAll(['owner', 'name', 'size', 'storagePath', 'encryptedKeys', 'sharedWith', 'createdAt']) &&
        // Validate data types
        request.resource.data.owner is string &&
        request.resource.data.storagePath is string &&
        request.resource.data.encryptedKeys is map &&
        // Ensure user has an encrypted key for the file
        request.auth.uid in request.resource.data.encryptedKeys &&
        // Parent folder validation (if specified)
        (request.resource.data.parent == null || request.resource.data.parent is string) &&
        // userFolders validation (if specified)
        (!request.resource.data.keys().hasAny(['userFolders']) || 
         (request.resource.data.userFolders is map && 
          request.auth.uid in request.resource.data.userFolders.keys())) &&
        // userFavorites validation (if specified)
        (!request.resource.data.keys().hasAny(['userFavorites']) || 
         (request.resource.data.userFavorites is map && 
          request.auth.uid in request.resource.data.userFavorites.keys())) &&
        // userNames validation (if specified)
        (!request.resource.data.keys().hasAny(['userNames']) || 
         (request.resource.data.userNames is map && 
          request.auth.uid in request.resource.data.userNames.keys()));
    }
    
    // Groups - users can access groups they own or are members of
    match /groups/{groupId} {
      // Read access: owner or member (encrypted groups rely on memberKeys)
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.owner ||
        (resource.data.members is list && request.auth.uid in resource.data.members) ||
        (resource.data.isEncrypted == true && resource.data.memberKeys is map && request.auth.uid in resource.data.memberKeys.keys())
      );
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner
      allow create: if isOwner(request.resource.data) &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['owner', 'name', 'members', 'createdAt', 'updatedAt']) &&
        // For encrypted groups, check memberKeys contains owner
        (request.resource.data.isEncrypted != true || 
         (request.resource.data.memberKeys is map && request.auth.uid in request.resource.data.memberKeys.keys())) &&
        // For unencrypted groups, check members list contains owner
        (request.resource.data.isEncrypted == true || 
         (request.resource.data.members is list && request.auth.uid in request.resource.data.members && request.resource.data.members.size() <= 50));
    }
    
    // Sharing History - users can only access their own sharing history
    match /sharingHistory/{historyId} {
      // Read access: only owner
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner
      allow create: if isOwner(request.resource.data) &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['owner', 'sharedWith', 'sharedAt', 'type']) &&
        // Validate data types
        request.resource.data.owner is string &&
        request.resource.data.sharedWith is string &&
        request.resource.data.type in ['user', 'group'];
    }
    
    // Form Templates - public templates accessible by all, private templates by owner/shared users
    match /formTemplates/{templateId} {
      // Helper function to check if user can access template
      function canAccessTemplate(templateData) {
        return templateData.isPublic == true || 
               request.auth.uid == templateData.author ||
               (templateData.sharedWith is list && request.auth.uid in templateData.sharedWith);
      }
      
      // Read access: public templates, owned templates, or shared templates
      allow read: if request.auth != null && canAccessTemplate(resource.data);
      
      // Write access: only template author can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.author;
      
      // Create access: must be author
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.author &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['name', 'author', 'isPublic', 'isOfficial', 'schema', 'defaultData', 'usageCount', 'createdAt', 'updatedAt']) &&
        // Validate data types
        request.resource.data.name is string &&
        request.resource.data.author is string &&
        request.resource.data.isPublic is bool &&
        request.resource.data.isOfficial is bool &&
        request.resource.data.schema is map &&
        request.resource.data.defaultData is map &&
        request.resource.data.usageCount is number &&
        // Only allow isOfficial=true if user has admin claim (you'll need to set this in custom claims)
        (request.resource.data.isOfficial == false || request.auth.token.admin == true) &&
        // Validate sharedWith array if present
        (!request.resource.data.keys().hasAny(['sharedWith']) || 
         (request.resource.data.sharedWith is list && request.resource.data.sharedWith.size() <= 100));
    }
    
    // Custom Templates - users can manage their own templates, read public ones
    match /customTemplates/{templateId} {
      // Helper function to check if user can access template
      function canAccessCustomTemplate(templateData) {
        return templateData.isPublic == true || 
               request.auth.uid == templateData.userId;
      }
      
      // Read access: public templates or owned templates
      allow read: if request.auth != null && canAccessCustomTemplate(resource.data);
      
      // Write access: only template owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Create access: must be owner
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['templateId', 'name', 'userId', 'isCustom', 'schema', 'created', 'modified']) &&
        // Validate data types
        request.resource.data.templateId is string &&
        request.resource.data.name is string &&
        request.resource.data.userId is string &&
        request.resource.data.isCustom == true &&
        request.resource.data.schema is map &&
        // Validate that isPublic is boolean if present
        (!request.resource.data.keys().hasAny(['isPublic']) || request.resource.data.isPublic is bool) &&
        // Custom templates can never be official
        (!request.resource.data.keys().hasAny(['isOfficial']) || request.resource.data.isOfficial == false);
    }
    
    // Notifications - users can only read their own, creation restricted to server-side
    match /notifications/{notificationId} {
      // Read access: only recipient can read their notifications
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.recipientId;
      
      // Write access: NO client-side creation allowed - only Cloud Functions
      // Users can only update their own notifications to mark as read
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.recipientId &&
        // Only allow updating isRead and readAt fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead', 'readAt']) &&
        request.resource.data.isRead == true;
      
      // Create/Delete: DENIED - only Cloud Functions can create/delete notifications
      allow create, delete: if false;
    }
    
    // Contacts - users can manage their contact relationships
    match /contacts/{contactId} {
      // Contact ID format: {smallerUserId}_{largerUserId}
      function isValidContactId() {
        let userIds = contactId.split('_');
        return userIds.size() == 2 && 
               (request.auth.uid == userIds[0] || request.auth.uid == userIds[1]) &&
               userIds[0] < userIds[1]; // Ensure proper ordering
      }
      
      function isParticipant(contactData) {
        return request.auth.uid == contactData.userId1 || 
               request.auth.uid == contactData.userId2;
      }
      
      function userCanAccessContactId() {
        let userIds = contactId.split('_');
        return userIds.size() == 2 && 
               (request.auth.uid == userIds[0] || request.auth.uid == userIds[1]);
      }
      
      // Read access: participants can read their contacts (including non-existent ones)
      allow read: if request.auth != null && 
        userCanAccessContactId();
        
      // List access: allow querying contacts where user is participant
      allow list: if request.auth != null;
      
      // Write access: participants can update contact status
      allow update: if request.auth != null && 
        isValidContactId() &&
        isParticipant(resource.data) &&
        // Only allow updating specific fields
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'blockedAt', 'blockedByUserId', 'lastInteractionAt', 'metadata']) &&
        // Status must be valid
        request.resource.data.status in ['accepted', 'blocked'] &&
        // If blocking, must be done by authenticated user
        (request.resource.data.status != 'blocked' || request.resource.data.blockedByUserId == request.auth.uid);
      
      // Create access: must involve authenticated user and have proper structure
      allow create: if request.auth != null && 
        isValidContactId() &&
        isParticipant(request.resource.data) &&
        // Ensure required fields (allow additional optional fields like acceptedAt, metadata)
        request.resource.data.keys().hasAll(['userId1', 'userId2', 'user1Email', 'user2Email', 'user1DisplayName', 'user2DisplayName', 'status', 'initiatorUserId', 'createdAt', 'lastInteractionAt']) &&
        // Validate data types and values
        request.resource.data.userId1 is string &&
        request.resource.data.userId2 is string &&
        request.resource.data.status in ['accepted', 'blocked'] &&
        // Authenticated user must be either participant (not just initiator)
        (request.auth.uid == request.resource.data.userId1 || request.auth.uid == request.resource.data.userId2) &&
        // Ensure proper user ID ordering
        request.resource.data.userId1 < request.resource.data.userId2;
      
      // Delete access: participants can remove contact relationships
      allow delete: if request.auth != null && 
        isValidContactId() &&
        isParticipant(resource.data);
    }
    
    // Contact Requests - users can send and receive contact requests
    match /contactRequests/{requestId} {
      // Read access: sender or recipient
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.fromUserId || 
         request.auth.uid == resource.data.toUserId);
      
      // Write access: recipient can accept/decline, sender can cancel
      allow update: if request.auth != null && 
        ((request.auth.uid == resource.data.toUserId &&
          // Recipient can accept or decline
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt']) &&
          request.resource.data.status in ['accepted', 'declined']) ||
         (request.auth.uid == resource.data.fromUserId &&
          // Sender can cancel
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']) &&
          request.resource.data.status == 'cancelled'));
      
      // Create access: temporarily allow all authenticated users for debugging
      allow create: if request.auth != null;
      
      // Delete access: sender can delete their own requests
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.fromUserId;
    }
    
    // Contact Settings - users can manage their own contact settings
    match /contactSettings/{userId} {
      // Read/Write access: only the user themselves
      allow read, write: if request.auth != null && 
        request.auth.uid == userId;
      
      // Create access: must be for authenticated user
      allow create: if request.auth != null && 
        request.auth.uid == userId &&
        request.resource.data.userId == userId &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['userId', 'autoAcceptDomains', 'autoAcceptFromContacts', 'allowFileShareFromUnknown', 'blockUnknownUsers', 'notifyOnContactRequest', 'notifyOnFileShareFromUnknown', 'updatedAt']) &&
        // Validate data types
        request.resource.data.autoAcceptDomains is list &&
        request.resource.data.autoAcceptFromContacts is bool &&
        request.resource.data.allowFileShareFromUnknown is bool &&
        request.resource.data.blockUnknownUsers is bool &&
        request.resource.data.notifyOnContactRequest is bool &&
        request.resource.data.notifyOnFileShareFromUnknown is bool;
    }

    // User Invitations - invitations to non-existing users
    match /userInvitations/{invitationId} {
      // Read access: sender can read their own invitations
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.fromUserId;
        
      // List access: allow querying invitations where user is sender
      allow list: if request.auth != null;
      
      // Create access: sender creates invitation
      allow create: if request.auth != null;
      
      // Update access: sender can update their own invitations
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.fromUserId;
      
      // Delete access: sender can delete their own invitations
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.fromUserId;
    }
    
    // Deny all other access - explicit security
    match /{document=**} {
      allow read, write: if false;
    }
  }
}