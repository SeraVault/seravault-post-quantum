rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user has access to a resource
    function hasAccess(resource) {
      return request.auth != null && (
        request.auth.uid == resource.data.owner ||
        (resource.data.sharedWith is list && request.auth.uid in resource.data.sharedWith)
      );
    }
    
    // Helper function to validate user owns the resource being created
    function isOwner(resourceData) {
      return request.auth != null && request.auth.uid == resourceData.owner;
    }
    
    // Helper function to ensure sharedWith array is properly formatted
    function validSharedWith(sharedWith) {
      return sharedWith is list && 
             sharedWith.size() <= 100 && // Reasonable limit
             request.auth.uid in sharedWith; // Creator must be in sharedWith list
    }
    
    // Users can read and write their own profile
    match /users/{userId} {
      // Full read/write access to own profile
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow authenticated users to query users by email for sharing purposes
      // This allows reading public profile info (email, publicKey, displayName) needed for encryption and sharing
      // Private keys are stored encrypted so this is safe
      allow read: if request.auth != null;
    }
    
    // Folders - OWNER ONLY ACCESS (folders are not shared, only files within them)
    match /folders/{folderId} {
      // Read access: OWNER ONLY - folders themselves are private
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Write access: OWNER ONLY
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner - no sharing for folders themselves
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.owner &&
        // Ensure required fields are present
        request.resource.data.keys().hasAll(['owner', 'name', 'parent', 'createdAt']) &&
        // Validate data types
        request.resource.data.owner is string &&
        (request.resource.data.parent == null || request.resource.data.parent is string);
    }
    
    // Files (including forms) - users can access files they own or files shared with them
    match /files/{fileId} {
      // Read access: owner or explicitly shared user
      allow read: if hasAccess(resource);
      
      // List access: allow querying files where user is owner or in sharedWith array
      allow list: if request.auth != null;
      
      // Write access: only owner can modify most fields
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Allow users with access to update only their favorite status (legacy field)
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isFavorite', 'lastModified']) &&
        request.resource.data.isFavorite is bool;
        
      // Allow users with access to update their own favorite status in userFavorites
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userFavorites', 'lastModified']) &&
        request.resource.data.userFavorites is map &&
        // Only allow modification of the user's own favorite status
        request.auth.uid in request.resource.data.userFavorites.keys() &&
        request.resource.data.userFavorites[request.auth.uid] is bool;
      
      // Allow users with access to update their own folder association in userFolders
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userFolders']) &&
        request.resource.data.userFolders is map &&
        // Only allow modification of the user's own folder association
        (request.resource.data.userFolders.size() == resource.data.get('userFolders', {}).size() ||
         request.resource.data.userFolders.size() == resource.data.get('userFolders', {}).size() + 1) &&
        // Ensure user can only modify their own entry
        request.auth.uid in request.resource.data.userFolders.keys();
      
      // Allow users with access to update their own encrypted tags in userTags
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userTags']) &&
        request.resource.data.userTags is map &&
        // Only allow modification of the user's own encrypted tags
        (request.resource.data.userTags.size() == resource.data.get('userTags', {}).size() ||
         request.resource.data.userTags.size() == resource.data.get('userTags', {}).size() + 1) &&
        // Ensure user can only modify their own entry and it's properly encrypted
        request.auth.uid in request.resource.data.userTags.keys() &&
        request.resource.data.userTags[request.auth.uid] is map &&
        request.resource.data.userTags[request.auth.uid].keys().hasAll(['ciphertext', 'nonce']) &&
        request.resource.data.userTags[request.auth.uid].ciphertext is string &&
        request.resource.data.userTags[request.auth.uid].nonce is string;
      
      // Allow users with access to update their own personalized name in userNames
      allow update: if request.auth != null && 
        hasAccess(resource) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userNames', 'lastModified']) &&
        request.resource.data.userNames is map &&
        // Only allow modification of the user's own personalized name
        (request.resource.data.userNames.size() == resource.data.get('userNames', {}).size() ||
         request.resource.data.userNames.size() == resource.data.get('userNames', {}).size() + 1) &&
        // Ensure user can only modify their own entry and it's properly encrypted
        request.auth.uid in request.resource.data.userNames.keys() &&
        request.resource.data.userNames[request.auth.uid] is map &&
        request.resource.data.userNames[request.auth.uid].keys().hasAll(['ciphertext', 'nonce']) &&
        request.resource.data.userNames[request.auth.uid].ciphertext is string &&
        request.resource.data.userNames[request.auth.uid].nonce is string;
      
      // Create access: must be owner and include self in sharedWith
      allow create: if isOwner(request.resource.data) && 
        validSharedWith(request.resource.data.sharedWith) &&
        // Ensure required fields are present for files/forms
        request.resource.data.keys().hasAll(['owner', 'name', 'size', 'storagePath', 'encryptedKeys', 'sharedWith', 'createdAt']) &&
        // Validate data types
        request.resource.data.owner is string &&
        request.resource.data.storagePath is string &&
        request.resource.data.encryptedKeys is map &&
        // Ensure user has an encrypted key for the file
        request.auth.uid in request.resource.data.encryptedKeys &&
        // Parent folder validation (if specified)
        (request.resource.data.parent == null || request.resource.data.parent is string) &&
        // userFolders validation (if specified)
        (!request.resource.data.keys().hasAny(['userFolders']) || 
         (request.resource.data.userFolders is map && 
          request.auth.uid in request.resource.data.userFolders.keys())) &&
        // userFavorites validation (if specified)
        (!request.resource.data.keys().hasAny(['userFavorites']) || 
         (request.resource.data.userFavorites is map && 
          request.auth.uid in request.resource.data.userFavorites.keys())) &&
        // userNames validation (if specified)
        (!request.resource.data.keys().hasAny(['userNames']) || 
         (request.resource.data.userNames is map && 
          request.auth.uid in request.resource.data.userNames.keys()));
    }
    
    // Groups - users can access groups they own or are members of
    match /groups/{groupId} {
      // Read access: owner or member
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.owner ||
        (resource.data.members is list && request.auth.uid in resource.data.members)
      );
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner and include self in members
      allow create: if isOwner(request.resource.data) &&
        request.resource.data.members is list &&
        request.auth.uid in request.resource.data.members &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['owner', 'name', 'members', 'createdAt', 'updatedAt']) &&
        // Reasonable member limit
        request.resource.data.members.size() <= 50;
    }
    
    // Sharing History - users can only access their own sharing history
    match /sharingHistory/{historyId} {
      // Read access: only owner
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Write access: only owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.owner;
      
      // Create access: must be owner
      allow create: if isOwner(request.resource.data) &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['owner', 'sharedWith', 'sharedAt', 'type']) &&
        // Validate data types
        request.resource.data.owner is string &&
        request.resource.data.sharedWith is string &&
        request.resource.data.type in ['user', 'group'];
    }
    
    // Form Templates - public templates accessible by all, private templates by owner/shared users
    match /formTemplates/{templateId} {
      // Helper function to check if user can access template
      function canAccessTemplate(templateData) {
        return templateData.isPublic == true || 
               request.auth.uid == templateData.author ||
               (templateData.sharedWith is list && request.auth.uid in templateData.sharedWith);
      }
      
      // Read access: public templates, owned templates, or shared templates
      allow read: if request.auth != null && canAccessTemplate(resource.data);
      
      // Write access: only template author can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.author;
      
      // Create access: must be author
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.author &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['name', 'author', 'isPublic', 'isOfficial', 'schema', 'defaultData', 'usageCount', 'createdAt', 'updatedAt']) &&
        // Validate data types
        request.resource.data.name is string &&
        request.resource.data.author is string &&
        request.resource.data.isPublic is bool &&
        request.resource.data.isOfficial is bool &&
        request.resource.data.schema is map &&
        request.resource.data.defaultData is map &&
        request.resource.data.usageCount is number &&
        // Only allow isOfficial=true if user has admin claim (you'll need to set this in custom claims)
        (request.resource.data.isOfficial == false || request.auth.token.admin == true) &&
        // Validate sharedWith array if present
        (!request.resource.data.keys().hasAny(['sharedWith']) || 
         (request.resource.data.sharedWith is list && request.resource.data.sharedWith.size() <= 100));
    }
    
    // Custom Templates - users can manage their own templates, read public ones
    match /customTemplates/{templateId} {
      // Helper function to check if user can access template
      function canAccessCustomTemplate(templateData) {
        return templateData.isPublic == true || 
               request.auth.uid == templateData.userId;
      }
      
      // Read access: public templates or owned templates
      allow read: if request.auth != null && canAccessCustomTemplate(resource.data);
      
      // Write access: only template owner can modify
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Create access: must be owner
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.userId &&
        // Ensure required fields
        request.resource.data.keys().hasAll(['templateId', 'name', 'userId', 'isCustom', 'schema', 'created', 'modified']) &&
        // Validate data types
        request.resource.data.templateId is string &&
        request.resource.data.name is string &&
        request.resource.data.userId is string &&
        request.resource.data.isCustom == true &&
        request.resource.data.schema is map &&
        // Validate that isPublic is boolean if present
        (!request.resource.data.keys().hasAny(['isPublic']) || request.resource.data.isPublic is bool) &&
        // Custom templates can never be official
        (!request.resource.data.keys().hasAny(['isOfficial']) || request.resource.data.isOfficial == false);
    }
    
    // Deny all other access - explicit security
    match /{document=**} {
      allow read, write: if false;
    }
  }
}